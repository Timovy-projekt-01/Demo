<?php

namespace App\Ontologies\Malware;

use App\Ontologies\Helpers\HttpService;
use Illuminate\Support\Facades\Cache;

class Queries
{
    private $httpService;
    private $feiOntology = 'http://stufei/ontologies/malware#';
    public function __construct(HttpService $httpService)
    {
        $this->httpService = $httpService;
    }

    /**
     * Retrieves entities related to the given technique ID based on the two relation types
     * and map it to the relative relation type and proper structure. so code doesnt break later in Service::class
     * @param string $techniqueId The technique ID.
     * @param string $relationType1 The first relation type.
     * @param string $relationType2 The second relation type.
     * @return array The array of related entities.
     */
    private function getRelations(string $techniqueId, string $relationType1, string $relationType2)
    {
        // Query to retrieve entities related to the given technique ID based on the two relation types
        $query = 'SELECT ?entity
            WHERE {
                {
                    ?entity <' . $this->feiOntology . $relationType1 . '> ?id .
                    FILTER regex(str(?id), "' . $techniqueId . '")
                }
                UNION
                {
                    ?entity <' . $this->feiOntology . $relationType2 . '> ?id .
                    FILTER regex(str(?id), "' . $techniqueId . '")
                }
            }';

        // Perform the query and get the result
        $result = $this->httpService->get($query);
        foreach ($result as $key => $item) {
            $entityValue = $this->extractValue($item['entity']['value']);
            switch (substr($entityValue, 0, 1)) {
                case 'M':
                    $propertyVal = 'mitigates';
                    break;
                case 'T':
                    $propertyVal = 'usesTechnique';
                    break;
                case 'G':
                    $propertyVal = 'usedInTactic';
                    break;
                case 'S':
                    $propertyVal = 'usesSoftware';
                    break;
            }
            $result[$key] = [
                "property" => ["type" => "uri", "value" => $propertyVal],
                "value" => ["type" => "uri", "value" => $entityValue],
            ];

        }
        return $result;
    }
    /**
     * Retrieves the names of entities based on their IDs.
     *
     * @param array $entityIds An array of entity IDs.
     * @return array An array of entity names.
     */
    public function getNames(array $entityIds): array
    {
        $results = [];
        foreach (array_chunk($entityIds, 100) as $chunk) {
            $ids = implode(" ", array_map(function ($id) {
                return "<http://stufei/ontologies/malware#{$id}>";
            }, $chunk));
            $query = "SELECT ?entity ?name
                  WHERE {
                      VALUES ?entity { {$ids} }
                      ?entity <http://stufei/ontologies/malware#hasName> ?name .
                  }";

            $chunkResult = $this->httpService->get($query);
            array_push($results, ...$chunkResult);
        }

        $names = [];
        foreach ($results as $result) {
            $names[] = $result['name']['value'];
        }

        return $names;
    }
    /**
     * Searches for entities based on a given search term.
     *
     * @param string $searchTerm The search term to filter entities.
     * @return array The parsed data containing the entities, properties, and values.
     */
    public function searchEntities(string $searchTerm)
    {
        $query = 'SELECT ?entity ?property ?value
                    WHERE {
                    ?entity ?property ?value .
                    FILTER (regex(?value, "^' . $searchTerm . '", "i")) .
                    FILTER (?property IN (
                        <' . $this->feiOntology . 'hasName>,
                        <' . $this->feiOntology . 'name>,
                        <' . $this->feiOntology . 'hasSubmitName>
                    )) .
                    }
                    LIMIT 3';
        $result = $this->httpService->get($query);
        $parsedData = $this->parseValues($result);

        return $parsedData;
    }

    /**
     * Retrieves the raw malware properties for a given entity ID.
     *
     * @param string $entityId The ID of the entity.
     * @return array The parsed data containing the properties and their values.
     */
    public function getRawMalwareProperties($entityId)
    {
        $query = 'SELECT ?property ?value WHERE {
                    <'. $this->feiOntology . $entityId . '> ?property ?value.
                    }';

        $result = $this->httpService->get($query);

        if ($this->isTechnique($result)) {
           $relations = $this->getRelations($entityId, 'mitigates', 'usesTechnique');
           $result = array_merge($result, $relations);
        }
        $parsedData = $this->parseValues($result);
        return $parsedData;
    }
    private function isTechnique(array $result)
    {
        foreach ($result as $item) {
            $propertyValues = array_column($item, 'value', 'proeprty');
            if (strcmp($propertyValues[1], $this->feiOntology . "Technique") == 0) {
                return true; // Is technique
            }
        }
        return false; // Is not technique
    }

    /**
     * Parses $rawData to extract the values from the URIs.
     *
     * @param array $rawData The raw data array to be parsed.
     * @return array The parsed data array.
     */
    private function parseValues($rawData)
    {
        //dump($rawData);
        $parsedData = array_map(function ($item) {
            if (isset($item['entity']['value'])) {
                $item['entity']['value'] = $this->extractValue($item['entity']['value']);
            }
            if (isset($item['property']['value'])) {
                $item['property']['value'] = $this->extractValue($item['property']['value']);
            }
            if (isset($item['value']['value'])) {
                $item['value']['value'] = $this->extractValue($item['value']['value']);
            }
            return $item;
        }, $rawData);
        return $parsedData;
    }

    /**
     * Extracts the value after the last occurrence of a character in a URI.
     *
     * @param string $uri The URI to extract the value from.
     * @param string $charToFind The character to search for in the URI. Default is '#'.
     * @return string The extracted value from the URI, or the entire URI if the character is not found.
     */
    private function extractValue($uri, $charToFind = '#')
    {
        if ($uri && strpos($uri, $charToFind) !== false) {
            $hashtagIndex = strrpos($uri, $charToFind);
            return substr($uri, $hashtagIndex + 1);
        }
        return $uri; // Return the entire URI if the character is not found
    }
}
