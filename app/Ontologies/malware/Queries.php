<?php

namespace App\Ontologies\Malware;

use App\Ontologies\Helpers\HttpService;
use Illuminate\Support\Facades\Cache;

class Queries
{
    private $httpService;
    private $feiOntology = 'http://stufei/ontologies/malware#';
    public function __construct(HttpService $httpService)
    {
        $this->httpService = $httpService;
    }


    /**
     * Retrieves entities related to a given technique ID based on two different relation types.
     *
     * @param string $techniqueId The ID of the technique.
     * @param string $relationType1 The first relation type.
     * @param string $relationType2 The second relation type.
     * @return array The parsed data containing the related entities.
     */
    private function getRelations(string $techniqueId, string $relationType1, string $relationType2)
    {
        // Query to retrieve entities related to the given technique ID based on the two relation types
        $query = 'SELECT ?entity
            WHERE {
                {
                    ?entity <' . $this->feiOntology . $relationType1 . '> ?id .
                    FILTER regex(str(?id), "' . $techniqueId . '")
                }
                UNION
                {
                    ?entity <' . $this->feiOntology . $relationType2 . '> ?id .
                    FILTER regex(str(?id), "' . $techniqueId . '")
                }
            }';

        // Perform the query and get the result
        $result = $this->httpService->get($query);
        foreach ($result as $key => $item) {
            $entityValue = $this->extractValue($item['entity']['value']);
            $propertyVal = '';
            switch (substr($entityValue, 0, 1)) {
                case 'M':
                    $propertyVal = 'hasMitigators';
                    break;
                case 'T':
                    $propertyVal = 'usesTechnique';
                    break;
                case 'G':
                    $propertyVal = 'usedInTactic';
                    break;
                case 'S':
                    $propertyVal = 'usesSoftware';
                    break;
            }
            $result[$key] = [
                "property" => ["type" => "uri", "value" => $propertyVal],
                "value" => ["type" => "uri", "value" => $entityValue],
            ];

            // You can add more conditions for other mappings here...
        }
        return $result;
    }
    /**
     * Retrieves the names of entities based on their IDs.
     *
     * @param array $entityIds An array of entity IDs.
     * @return array An array of entity names.
     */
    public function getNames(array $entityIds): array
    {
        $ids = implode(" ", array_map(function ($id) {
            return "<http://stufei/ontologies/malware#{$id}>";
        }, $entityIds));
        //dd($ids);
        $query = "SELECT ?entity ?name
              WHERE {
                  VALUES ?entity { {$ids} }
                  ?entity <http://stufei/ontologies/malware#hasName> ?name .
              }";

        $results = $this->httpService->get($query);

        $names = [];
        foreach ($results as $result) {
            $names[] = $result['name']['value'];
        }

        return $names;
    }
    /**
     * Searches for entities based on a given search term.
     *
     * @param string $searchTerm The search term to filter entities.
     * @return array The parsed data containing the entities, properties, and values.
     */
    public function searchEntities(string $searchTerm)
    {
        $query = 'SELECT ?entity ?property ?value
                    WHERE {
                    ?entity ?property ?value .
                    FILTER (regex(?value, "^' . $searchTerm . '", "i")) .
                    FILTER (?property IN (
                        <http://stufei/ontologies/malware#hasName>,
                        <http://stufei/ontologies/malware#name>,
                        <http://stufei/ontologies/malware#hasSubmitName>
                    )) .
                    }
                    LIMIT 5';
        $result = $this->httpService->get($query);
        $parsedData = $this->parseValues($result);

        return $parsedData;
    }

    /**
     * Retrieves the raw malware properties for a given entity ID.
     *
     * @param string $entityId The ID of the entity.
     * @return array The parsed data containing the properties and their values.
     */
    public function getRawMalwareProperties($entityId)
    {
        $query = 'SELECT ?property ?value WHERE {
                    <http://stufei/ontologies/malware#' . $entityId . '> ?property ?value.
                    }';

        $result = $this->httpService->get($query);
        if ($this->isTechnique($result)) {
           $relations = $this->getRelations($entityId, 'mitigates', 'usesTechnique');
           $result = array_merge($result, $relations);
        }
        //dd($result);
        $parsedData = $this->parseValues($result);
        return $parsedData;
    }
    private function isTechnique(array $result)
    {
        foreach ($result as $item) {
            $propertyValues = array_column($item, 'value', 'proeprty');
            if (strcmp($propertyValues[1], $this->feiOntology . "Technique") == 0) {
                return true; // Is technique
            }
        }
        return false; // Is not technique
    }

    /**
     * Parses the values in the given raw data array.
     *
     * @param array $rawData The raw data array to be parsed.
     * @return array The parsed data array.
     */
    private function parseValues($rawData)
    {
        //dump($rawData);
        $parsedData = array_map(function ($item) {
            if (isset($item['entity']['value'])) {
                $item['entity']['value'] = $this->extractValue($item['entity']['value']);
            }
            if (isset($item['property']['value'])) {
                $item['property']['value'] = $this->extractValue($item['property']['value']);
            }
            if (isset($item['value']['value'])) {
                $item['value']['value'] = $this->extractValue($item['value']['value']);
            }
            return $item;
        }, $rawData);
        return $parsedData;
    }

    /**
     * Extracts the value after the last occurrence of a character in a URI.
     *
     * @param string $uri The URI to extract the value from.
     * @param string $charToFind The character to search for in the URI. Default is '#'.
     * @return string The extracted value from the URI, or the entire URI if the character is not found.
     */
    private function extractValue($uri, $charToFind = '#')
    {
        if ($uri && strpos($uri, $charToFind) !== false) {
            $hashtagIndex = strrpos($uri, $charToFind);
            return substr($uri, $hashtagIndex + 1);
        }
        return $uri; // Return the entire URI if the character is not found
    }
}
