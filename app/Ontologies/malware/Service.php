<?php

namespace App\Ontologies\Malware;

use App\Exceptions\ScriptFailedException;
use App\Ontologies\Helpers\HttpService;
use App\Ontologies\Malware\Queries;
use App\Ontologies\Malware\ServiceInterface;

class Service implements InterfaceService
{
    private $sparql;
    protected $propertyTypes = [
        'TYPE' => 'type',
        'DOMAIN' => 'hasDomain',
        'RANGE' => 'range',
        'MITIGATES' => 'mitigates',
        'HAS_DESCRIPTION' => 'hasDescription',
        'HAS_CONTRIBUTORS' => 'hasContributors',
        'HAS_DATA_SOURCES' => 'hasDataSources',
        'HAS_ID' => 'hasId',
        'HAS_NAME' => 'hasName',
        'HAS_PLATFORMS' => 'hasPlatforms',
        'HAS_RELATIONSHIP_CITATIONS' => 'hasRelationshipCitations',
        'HAS_PERMISSIONS_REQUIRED' => 'hasPermissionsRequired',
        'HAS_CAPEC_ID' => 'hasCapecId',
        'HAS_MTC_ID' => 'hasMtcId',
        'HAS_ALIASES' => 'hasAliases',
        'HAS_URL' => 'hasUrl',
        'HAS_VERSION' => 'hasVersion',
        'HAS_SYSTEM_REQUIREMENTS' => 'hasSystemRequirements',
        'HAS_MITIGATORS' => 'hasMitigators',
        'USES_SOFTWARE' => 'usesSoftware',
        'USES_TECHNIQUE' => 'usesTechnique',
        'IS_SUBTECHNIQUE' => 'isSubTechnique',
        'IS_SUBTECHNIQUE_OF' => 'isSubTechniqueOf',
        'WAS_CREATED' => 'wasCreated',
        'WAS_LAST_MODIFIED' => 'wasLastModified',
        'DATA_TYPE_PROPERTY' => 'DatatypeProperty',
        'FUNCTIONAL_PROPERTY' => 'FunctionalProperty',
        'HAS_DEFENSES_BY_PASSED' => 'hasDefensesBypassed',
        'HAS_ASSOCIATED_GROUPS' => 'hasAssociatedGroups',
        'HAS_ASSOCIATED_GROUPS_CITATIONS' => 'hasAssociatedGroupsCitations',
        'HAS_DOMAIN' => 'hasDomain',
        'HAS_DETECTION' => 'hasDetection',
        'HAS_SUBTECHNIQUE' => 'hasSubTechnique',
        'HAS_MITTRE_ATTACK_SIGNATURE' => 'hasMitreAttckSignature',
        'HAS_EXTRACTED_FILE' => 'hasExtractedFile',
        'HAS_CROWD_STRIKE_AI' => 'hasCrowdStrikeAi',
        'HAS_ATTCK_TECHNIQUE' => 'hasAttckTechnique',
        'HAS_CERTIFICATE' => 'hasCertificate',
        'HAS_FILE_METADATA' => 'hasFileMetadata',
        'HAS_PROCESS' => 'hasProcess',
        'HAS_SUBMISSION' => 'hasSubmission',
    ];
    public function __construct(Queries $sparql)
    {
        $this->sparql = $sparql;
    }

    public function updateMalware(Parser $parser, HttpService $httpService): string
    {
        return $httpService->postOwl($parser->parseMalware());
    }

    public function getCleanMalwareProperties($id): array
    {
        $malware = [];
        $properties = $this->sparql->getRawMalwareProperties($id);
        if ($this->isTechnique($properties)) {
            $relationNames = $this->sparql->getRelations($id, 'mitigates', 'usesTechnique');
            $relationNames = $this->mapTechniqueRelations($relationNames);
            $properties = array_merge($properties, $relationNames);
        }
        $malware = $this->mapExistingData($malware, $properties);
        $malware = $this->getNamesToIds($malware, ['usesTechnique', 'usesSoftware', 'mitigates']);

        return $malware;
    }
    public function isTechnique(array $result)
    {
        foreach ($result as $item) {
            $propertyValues = array_column($item, 'value', 'propertyLocal');
            if (strcmp($propertyValues[1], "Technique") == 0) {
                return true; // Is technique
            }
        }
        return false; // Is not technique
    }

    public function mapExistingData(array $malware, array $properties): array {
        foreach ($properties as $prop) {
            $propertyName = $prop['propertyLocal']['value'];
            $propertyValue = $prop['valueLocal']['value'];

            // Check if the property already exists in $malware
            if (array_key_exists($propertyName, $malware)) {
                // If it exists, append the value to the existing array
                $malware[$propertyName][] = $propertyValue;
            } else {
                // If it doesn't exist, create a new array with the value
                $malware[$propertyName] = [$propertyValue];
            }
        }
        // Map the values into an associative array except arrays with more than one element.
        $malware = array_map(function ($values) {
            return count($values) > 1 ? $values : $values[0] ?? null;
        }, $malware);
        return $malware;
    }

    public function getNamesToIds($malware, array $colapsProps): array
    {

        foreach ($colapsProps as $colapsProp) {
            if (isset($malware[$colapsProp])) {
                $entityIds = $malware[$colapsProp];

                $results = [];
                foreach (array_chunk((array) $entityIds, 100) as $chunk) {
                    $ids = implode(" ", array_map(function ($id) {
                        return "<http://stufei/ontologies/malware#{$id}>";
                    }, $chunk));

                    $chunkResult = $this->sparql->getNames($ids);
                    array_push($results, ...$chunkResult);
                }
                $names = [];
                foreach ($results as $result) {
                    $names[] = $result['name']['value'];
                }
                // Map those names to IDs
                $malware[$colapsProp] = array_map(function ($id, $name) {
                    return ['id' => $id, 'name' => $name];
                }, (array) $malware[$colapsProp], (array)$names);
            }
        }
        return $malware;
    }

    public function mapTechniqueRelations($relations) {
        foreach ($relations as $key => $relation) {
            $entityValue = $relation['entityLocal']['value'];
            switch (substr($entityValue, 0, 1)) {
                case 'M':
                    $propertyVal = 'mitigates';
                    break;
                case 'T':
                    $propertyVal = 'usesTechnique';
                    break;
                case 'G':
                    $propertyVal = 'usedInTactic';
                    break;
                case 'S':
                    $propertyVal = 'usesSoftware';
                    break;
            }
            $relations[$key] = [
                "propertyLocal" => ["type" => "uri", "value" => $propertyVal],
                "valueLocal" => ["type" => "uri", "value" => $entityValue],
            ];
        }
        return $relations;
    }
}

?>
