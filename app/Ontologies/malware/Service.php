<?php

namespace App\Ontologies\Malware;

use App\Exceptions\ScriptFailedException;
use App\Ontologies\Helpers\HttpService;
use App\Ontologies\Malware\Queries;
class Service
{
    private $sparql;
    protected $propertyTypes = [
        'TYPE' => 'type',
        'DOMAIN' => 'hasDomain',
        'RANGE' => 'range',
        'MITIGATES' => 'mitigates',
        'HAS_DESCRIPTION' => 'hasDescription',
        'HAS_CONTRIBUTORS' => 'hasContributors',
        'HAS_DATA_SOURCES' => 'hasDataSources',
        'HAS_ID' => 'hasId',
        'HAS_NAME' => 'hasName',
        'HAS_PLATFORMS' => 'hasPlatforms',
        'HAS_RELATIONSHIP_CITATIONS' => 'hasRelationshipCitations',
        'HAS_PERMISSIONS_REQUIRED' => 'hasPermissionsRequired',
        'HAS_CAPEC_ID' => 'hasCapecId',
        'HAS_MTC_ID' => 'hasMtcId',
        'HAS_ALIASES' => 'hasAliases',
        'HAS_URL' => 'hasUrl',
        'HAS_VERSION' => 'hasVersion',
        'HAS_SYSTEM_REQUIREMENTS' => 'hasSystemRequirements',
        'HAS_MITIGATORS' => 'hasMitigators',
        'USES_SOFTWARE' => 'usesSoftware',
        'USES_TECHNIQUE' => 'usesTechnique',
        'IS_SUBTECHNIQUE' => 'isSubTechnique',
        'IS_SUBTECHNIQUE_OF' => 'isSubTechniqueOf',
        'WAS_CREATED' => 'wasCreated',
        'WAS_LAST_MODIFIED' => 'wasLastModified',
        'DATA_TYPE_PROPERTY' => 'DatatypeProperty',
        'FUNCTIONAL_PROPERTY' => 'FunctionalProperty',
        'HAS_DEFENSES_BY_PASSED' => 'hasDefensesBypassed',
        'HAS_ASSOCIATED_GROUPS' => 'hasAssociatedGroups',
        'HAS_ASSOCIATED_GROUPS_CITATIONS' => 'hasAssociatedGroupsCitations',
        'HAS_DOMAIN' => 'hasDomain',
        'HAS_DETECTION' => 'hasDetection',
        'HAS_SUBTECHNIQUE' => 'hasSubTechnique',
        'HAS_MITTRE_ATTACK_SIGNATURE' => 'hasMitreAttckSignature',
        'HAS_EXTRACTED_FILE' => 'hasExtractedFile',
        'HAS_CROWD_STRIKE_AI' => 'hasCrowdStrikeAi',
        'HAS_ATTCK_TECHNIQUE' => 'hasAttckTechnique',
        'HAS_CERTIFICATE' => 'hasCertificate',
        'HAS_FILE_METADATA' => 'hasFileMetadata',
        'HAS_PROCESS' => 'hasProcess',
        'HAS_SUBMISSION' => 'hasSubmission',
        'USED_IN_TACTIC' => 'usedInTactic',
    ];
    public function __construct(Queries $sparql)
    {
        $this->sparql = $sparql;
    }
    /**
     * Updates the malware using the provided parser.
     *
     * @param Parser $parser The parser used to parse the malware.
     * @return true If the malware was successfully updated. Otherwise, false.
     * @throws ScriptFailedException If the script fails to update the malware ontology.
     */
    public function updateMalware(Parser $parser, HttpService $httpService): string
    {   
        return $httpService->postOwl($parser->parseMalware());
    }

    /**
     * Parses all entity properties to remove things like uri, literal, and
     * returns an associative array with only the property and its value.
     *
     * @param int $id The ID of the malware entity.
     * @return array The cleaned malware properties.
     */
    public function getCleanMalwareProperties($id): array
    {
        $malware = [];
        $properties = $this->sparql->getRawMalwareProperties($id);
        // Fills the malware with all possible properties and their values.
        foreach ($this->propertyTypes as $type) {
            $malware[$type] = $this->extractPropertyVal($properties, $type);
        }
        //dd($malware);
        // Map the values into an associative array.
        $malware = array_map(function ($values) {
            return count($values) > 1 ? $values : $values[0] ?? null;
        }, $malware);

        $malware = $this->getNamesToIds($malware, ['usesTechnique', 'hasMitigators', 'usesSoftware', 'mitigates', 'usedInTactic']);

        return $malware;
    }

    /**
     * Helper function to extract the value for a specific property type from an array of properties.
     *
     * @param array $properties The array of properties to extract values from.
     * @param string $propertyType The property type to filter and extract values for.
     * @return array The extracted values for the specified property type.
     */
    private function extractPropertyVal($properties, $propertyType)
    {
        // Step 1: Filter elements with 'property' equal to 'propertyType',  hasAliases, hasUrl etc.
        $filteredData = array_filter($properties, fn ($element) => $element['property']['value'] == $propertyType);

        // Step 2: Get the 'value' of 'value' for each filtered element
        $extractedValues = array_map(fn ($element) => $element['value']['value'], array_values($filteredData));
        return $extractedValues;
    }

    /**
     * Retrieves the names corresponding to the IDs of the given malware properties.
     *
     * @param array $malware The malware data containing the properties.
     * @param array $propertyTypes The types of properties to retrieve names for.
     * @return array The updated malware data with names mapped to IDs.
     */
    private function getNamesToIds($malware, array $colapsProps)
    {
        // Iterate over each property type
       //dd($malware);
        foreach ($colapsProps as $colapsProp) {
            // Skip if property type not found in malware
            if (!isset($malware[$colapsProp])) {
                continue;
            }

            // Get names for each ID in one request
            $names = $this->sparql->getNames((array) $malware[$colapsProp]);

            // Map those names to IDs
            $malware[$colapsProp] = array_map(function ($id, $name) {
                return ['id' => $id, 'name' => $name];
            }, (array) $malware[$colapsProp], (array)$names);
        }

        return $malware;
    }
}

?>
